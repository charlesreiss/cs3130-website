---
title: Virtual memory exploration
author: Charles Reiss
...

<div class="oldsite">This lab is an incomplete draft and likely to change substantially.</div>

# Your Task

1.  Download the skeleton code ([here](files/vm-explore.tar)  or `wget https://www.cs.virginia.edu/~cr4bd/3130/S2024/labhw/files/vm-explore.tar`) and run `make` to compile it.

    (Note that this lab expects 64-bit Linux environment with 4096 byte pages, like on portal.)

    It will produce an executable caled `./lab`, which you can run with

        ./lab NUMBER

    where NUMBER is an integer that will be passed to the function `labStuff`
    which you will edit later in the lab. You can try `./lab 0` to see an example of the output.

    It displays the program's memory layout, then displays several statistics
    about the program's memory usage, then runs the function 
    `labStuff`, then prints the new memory usage and the new memory layout.

    When displaying memory usage, the program displays
        
    *  the "size", the size of available data and code, regardless of whether it
       is currently mapped in the page table or will be loaded on demand
    *  the "resident set size", which is essentially the size of loaded data and code
    *  the "page table size", which is the total size of all page tables for the program

    Your tasks in this lab will be to modify the program to change the values displayed
    for each of these by writing code in the function `labStuff`.

    In the exercises below, you'll modify `labStuff` to do some operations with memory and
    observe how they change those statistics.

## Part 1

1.  On Linux, the kernel usually sets up page table entries only at the last
    possible moment. That is, when a program first attempts to access a page,
    it will not yet be in the page table, then an exception will occur called
    a "page fault". Linux records the number of page faults that occur
    classifying them as "major" (requiring I/O) and "minor" (not requiring I/O).

    Make a global array like:

        volatile char global_array[4096 * 32];

    Declaring it as `volatile` will make our C compilers not optimize away memory
    accesses to the array^[This functionality is intended primarily for the purpose of
    supporting "memory-mapped I/O", where reading and writing memory locations
    causes an input or output operation to occur instead of just storing or
    retrieving values. So, generally, assembly
    that the compiler generates will not omit reads and writes to volatile values
    even if they superficially appear to do nothing.

    An alternate, more direct strategy to avoid such optimizations would be to use
    assembly to do the memory accesses.].

    From the code in `labStuff` when the parameter is `1`, access this array
    and run it, observing how:

    *  accessing it once increase the number of minor faults, and it does not matter if
       the access is a read or write
    *  as you access the array, the resident size (amount of memory actually assigned
       to the program) increases one page (4096 byte) units
    *  accessing it multiple times within the same page (4096 byte region)
       does not increase the number of minor faults
    *  accessing it in different pages increases the number of minor faults

## Part 2

1.  Modify labStuff to allocate 1MB when the parameter is `2`,

    Note that normally when you allocate memory and do not do something useful, the compiler might
    optimize away the memory access. To avoid this,

    *  pass compiler flags^[`-fno-builtin-malloc` and `-fno-builtin-calloc`] like our Makefile does that prevent `malloc` and `calloc` calls
       from being optimized away when their results seem not to be used (or use memory allocation
       functions like `mmap` that the compiler won't optimize away); and
    *  access the memory through pointers to a `volatile` type (such as by declaring a pointer with
       `volatile char *ptr;`) to discourage the compiler from optimizing away code that
       dereferences the pointer when it does not appear to do useful work.
    
    Observe how the resident set size changes substantailly less than the VM size.
    The VM size represents addresses assigned to the program, but those adresseses
    are not immediately assigned to useful storage. By default, this only happens
    as you actually access the memory.

    Modify your code to access a few bytes of the 1MB allocation, and observe
    how adding those accesses causes the "resident set size" to increase
    and minor fault count to increase, showing this.

## Part 3

2.  Linux usually actually allocates pages for data as it is accessed.

    Taking advantage of this modify the labStuff function when the parameter is `3`
    increase the "size" by 1MB and the "resident set size" by 128 KB (or as close to
    these numbers as you can get as possible).
    Do so with the fewest memory accesses you can to the allocated memory.

## Part 4

1.  As we'll learn later, the multi-level page table structure used on modern systems
    is more efficient when pages are closer to together. Explore this by allocating and
    using memory at addresses different distances from the allocation.

    A problem we'll run into in doing this is that Linux (and most current OSes) by
    default randomize addresses. We can avoid by this by running

        setarch --addr-no-randomize ./lab ...

    instead of

        setarch --addr-no-randomize ./lab ...

    After doing this, make `./lab 4` allocate memory at an address
    about `0x10000` bytes after the heap and allocate and use
    4096 bytes of memory at that location. To do this, I would
    recommend using `mmap` with `MAP_FIXED` or `MAP_FIXED_NOREPLACE`
    as discussed below.

    Then make `./lab 5` do the same thing but allocate memory at an addresss
    about  `0x10000000000` bytes after the heap.

    You should see `./lab 5` allocates several more pages for page tables
    than `./lab 4`, and most likely, both will require additional pages for page tables.

<!--
1.  Multi-level page tables are more space-efficient when the used pages are closer together.

    Modify the labStuff function so that when the paramter is `4` it allocates at most 128KB of
    memory for the program (as measured by "Size (bytes)")
    but uses as much much page table storage as possible (as measured by "PTE (bytes)").

    To do this, it will be helpful to know what the memory layout of the program is. Unfortuantely,
    this is randomzied by default. You can disable this by running the program with
    `setarch --addr-no-randomize ./lab ...` instead of `./lab ...`.

     I would recommend using
    `mmap` to allocate memory with `MAP_FIXED` to choose a particular address (as discussed below).

    To figure out what is the most possible, note that x86-64 Linux (as configured on portal, etc.)
    uses a 4-level page table with 4096 byte pages and 512 entries in page tables at each level.
-->

## Checkoff/Submission

1.  Show a TA your labStuff function and the `./lab` program operating for parts 2-4,
    or submit your lab.c to the submission site.

# Hints/Advice

## mmap generally

1.  The `mmap` library function (documented in `man mmap`) was originally built to load
    a file's data into a program's memory. For example:

        int file_descriptor = open("foo.dat", O_RDWR);
        if (file_descriptor < 0) { handle_error(); }
        char *ptr;
        ptr = mmap(NULL /* "hint" address, NULL for "don't care what address chosen" */,
                   8192 /* length of mapping */,
                   PROT_READ | PROT_WRITE /* types of access allowed */,
                   MAP_SHARED /* "flags" controlling mapping */,
                   file_descriptor,
                   0 /* offset in file */
        );
        if (ptr == MAP_FAILED) { handle_error(); }

    will make `ptr` point to the first 8192 bytes (two pages on x86-64 Linux) of the file `foo.dat`.
    Since `MAP_SHARED` was selected, modifying what `ptr` points to will modify the file `foo.dat`.
    (The modifications will be "shared" with other users of the file; the alternate `MAP_PRIVATE`
    will give a private copy of the file's data.)

## mmap for memory allocation 

2.  On Linux, `mmap` can also be used for memory allocation, without involving any actual files.
    To do this one supplies
    the invalid file descriptor `-1` and specifies `MAP_ANONYMOUS` as one of the 
    `mmap` "flags". (The mapping is anonymous in the sense that there is no file name it corresponds to.)
    For example, 

        char *ptr;
        ptr = mmap(NULL /* hint address */
                   8192 /* length */,
                   PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS,
                   -1 /* file descriptor (-1 for "none") */
                   0
            );
        if (ptr == MAP_FAILED) { handle_error(); }

    will make `ptr` point to a new allocation of 8192 bytes.

## MAP_FIXED_NOREPALCE and MAP_FIXED

3.  By defaut `mmap` chooses a new location for the mapping.

    But you can use the MAP_FIXED_NOREPLACE or MAP_FIXED flags to require the mapping be located in at
    a particular virtual address.

    For example:

        char *ptr;
        ptr = mmap(0x123456000,
                   8192,
                   PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED_NOREPLACE,
                   -1
                    0
            );
        if (ptr == MAP_FAILED) { handle_error(); }

    will allocate 8192 bytes of memory at virtual address 0x123456000 and set
    `ptr` to 0x123456000 if it succeeds. If something is already at that address
    or it fails for some other reason, `ptr` will be set to MAP_FAILED.

    Unlike MAP_FIXED_NOREPLACE, using MAP_FIXED will not fail if something is
    already allocated at the requested address; instead those address will be
    reassigned (probably breaking the program if anything important was there).

4.  Note that the location you specify must be at the beginning of a page,
    which on our systems is a multiple of 4096 (0x1000)
