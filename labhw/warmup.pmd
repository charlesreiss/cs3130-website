---
title: warmup
author: Charles Reiss
...

# Your task

1.  Create C files as follows:

    *  in `split.c`, write an implementation of the function 
        
            char **string_split(const char *input, const char *sep);

       The function should take a NUL-terminated string `input` and a 
       NUL-terminated string
       listing separating characters in `sep` and return a null-pointer-terminated
       array of "words" separated by a sequence of one or more
       of the characters in `sep`. The returned
       array and each of the strings in that array should be allocated so
       that they can be freed using `free()`.

       In addition:

       *  The function may not modify the input strings.
       *  The function may not leak memory. (When the function returns,
          the only newly allocated memory should be pointed to by the value returned.)
       *  We do not care what your function does if `input` is an empty string
          or if `sep` is an empty string.
       *  We do not care what your function does if allocating memory fails (provided
          that your function does not try to allocate a huge amount of memory relative
          to the size of its arguments)

       Some examples of using this function are shown below.

       Your implementation may use additional utility functions

    *  in `split.h`, write an appropriate header file declaring `split.c` and include
       [`#include` guards](https://en.wikipedia.org/wiki/Include_guard) to protect
       against multiple inclusion.

    *  in `main.c`, write a `main()` function that:

       *  constructs a value for `sep` by the command line arguments, or,
          if no command line arguments are provided, uses `" \t\n\f\v"`.
          When there are command-line arguments, 
          the value of `sep` should be the result of concatenating all the command line
          arguments. For example, if the `main()` is compiled into an executable `split`, then
          running

                ./split a b c

          or

               ./split abc
           
          or

               ./split ab c

          should choose a sep value of `abc`.

      *  reads lines of input (without prompting) of up to 4000 bytes. For each line, it should:

         *  exit if the line is one period (`.`) with no other text or whitespace;
         *  otherwise call `string_split` with that input and the chosen `sep` value,
            then print out the resulting array with each word surrounded by square
            brackets (`[` and `]`) and without spaces between words, followed by a newline, then frees
            the resulting array.

        Your program may not access out-of-bounds memory (such as might cause a segfault)
        if a line of input is longer than 4000 bytes, but otherwise, we do not care
        what it does for long input lines.
         

      (Some examples of expected transcripts are shown below.)

2.  Create a Makefile such that typing `make` will build (if necessary) `split.o`, `main.o`
    and link them into an executable `split`.

3.  Make sure your C files do not produce any warnings when compiled with `-Og -g -std=c11 -Wall -pedantic` (assuming GCC or Clang). (It is okay if your Makefile uses different options.)

4.  Make sure your code does not have memory leaks or errors. We will test your code with AddressSanitizer enabled to help check for this (which can be enabled by compiling and linking with `-fsanitize=address`).

#  Examples

##  `string_split`

1.  Running

        char **result;
        result = string_split("foo", ":");

    should have the same effect as

        result = calloc(sizeof(char *), 2);
        result[0] = malloc(4);
        strcpy(result[0], "foo");
        result[1] = NULL;

1.  Running

        char **result;
        result = string_split("foo:bar:quux", ":");

    or

        char **result;
        result = string_split("foo:bar!quux", "!:");

    or

        char **result;
        result = string_split("foo:bar!quux", ":!");

    should have the same effect as

        char **result;
        result = calloc(sizeof(char *), 4);
        result[0] = malloc(4);
        strcpy(result[0], "foo");
        result[1] = malloc(4);
        strcpy(result[0], "bar");
        result[2] = malloc(5);
        strcpy(result[0], "quux");
        result[3] = NULL;

1.  Running
    
        char **result;
        result = string_split(":foo!:bar::quux!", ":!");

    should have the same effect as

        char **result;
        result = calloc(sizeof(char *), 5)
        result[0] = malloc(1);
        strcpy(result[0], "");
        result[1] = malloc(4);
        strcpy(result[1], "foo");
        result[2] = malloc(4);
        strcpy(result[2], "bar");
        result[3] = malloc(5);
        strcpy(result[3], "quux");
        result[4] = malloc(1)
        strcpy(result[4], "");
        result[5] = NULL;

## `split` executable

In the following example transcripts **bold** represents input typed in and `$ ` represents
the shell's prompt:

### Example 1

<pre>
$ <b>./split</b>
<b>foo     bar   baz</b>
[foo][bar][baz]
<b>quux-no-space quux-with space !</b>
[quux-no-space][quux-with][space][!]
<b>   indented</b>
[][indented]
<b>.</b>
$ 
</pre>

### Example 2

<pre>
$ <b>./split XY Z</b>
<b>fooXXXXbarZXYXYXZbazYYYYY</b>
[foo][bar][baz][]
<b>XXXXXXXXXXXXX</b>
[][]
<b>X.X</b>
[][.][]
<b>.</b>
$ 
</pre>

# Hints

1.  I found the C standard library functions `strspn` and `strcspn` useful in my solution.

2.  To avoid scanning the string multiple times, you can use `realloc` to change the size of a dynamically allocated array. (But make sure to initialize any new space made by `realloc` --- it might not default to 0/NULL.)
