---
title: Side channel lab
author: Charles Reiss
...

>  This lab writeup is incomplete and likely to change substantially.

# Overview

In this lab, we will give you a `check_passphrase` function
that compares a phassphrase with a stored passphrase one
character at a time.

Your task is to write a function that will figure out 
the passphrase by calling `check_passphrase` and timing how
long it takes. Rather than trying all possible passphrases,
you should be able to tell whether you have the first few
characters correct by examining how long it takes
the function to run.

# Your Task

1.  Download the supplied skeleton code at TBA.

2.  In `lab.c` fill in the `find_passphrase(buffer, size)` function with a function
    which will figure out which passphrase `check_passphrase` accepts. To do so,
    you function must *only* use information obtained by running and timing
    `check_passphrase`.

    Your function may assume that passphrases consist of
    only of the letter `a` through `z` and are exactly `size` characters long.
    
    We've supplied a version of `find_passphrase` which times how long it take to
    execute with `a` and `b` and `c` and prints out how long each takes.

    A good solution should use substantially fewer guesses overall than trying
    all possible paswords of the specified length.

3.  Test your code with the supplied `main.c` file. After running `make`, the `./lab`
    program can be run like:

        ./lab password

    in which case it will set the passphrase to "password", invoke your `find_passphrase`
    function and report the results like:

        found passphrase [password] after 702 queries

    or, if your function fails, like

        found [z], but that was not the passphrase


# Suggested approach/Hints

1.  Modify the code to try all single-letter passwords and print out the timings for each.
    To get consistent measurements, I recommend obtaining all measurements in one loop.
    This should ensure that everything stays in caches and reduce variation from other things
    running on the system and/or variable clock rates.

2.  After you do that modification, look at the timings for

        ./lab foo

    versus, for example,

        ./lab zoo

    When I tried this, I found that

    *  the first thing timed is probably slow every time, probably because caches are not loaded yet
    *  the actual first letter is consistently substantially slower than most of the other letters

1.  I would recommend structuring your code like:

    *  Fill in the string with all \0s to start with an empty string.

    *  In a loop for each index *i* up to length:

        *  Try each possiblity for the *i*'th letter and see which seems most likely
           based on the timings

        *  Fill in the best guess of the *i*th letter for future iterations

    *  If you get to the end of the loop and none of the guesses were correct,
       repeat the process. Hopefully, this was just caused by something interfering
       with the timings that won't happen over and over again.

2.  To deal with the problem of the first thing timed being slow everytime, I would
    recommend taking multiple measurements for each letter
    and somehow discarding likely outliers.

    Taking multiple measurements will also help deal with other inconsistencies in timing.

    This does increase the number of check_passphrase calls, but should still be a lot
    better than guessing all possibilities.
